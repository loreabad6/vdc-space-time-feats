---
title: "Computational notebook"
bibliography: https://api.citedrive.com/bib/618133a2-4856-443b-b778-a72d316eb599/references.bib?x=eyJpZCI6ICI2MTgxMzNhMi00ODU2LTQ0M2ItYjc3OC1hNzJkMzE2ZWI1OTkiLCAidXNlciI6ICIyNTY4IiwgInNpZ25hdHVyZSI6ICI4MWExNDU3ODE3NWUxMzFiZDI1NDliOTg2NmQzMWJjNzU4OWI4YjI3MDUxOTU5NDg3MDM5MzFlYmQwMDY0OThhIn0=/bibliography.bib
format: 
  gfm: 
    toc: true
    toc-depth: 3
    number-sections: true
    fig-dpi: 300
editor_options: 
  chunk_output_type: console
---

# Context

This is a computational notebook to accompany the short paper manuscript "Vector data cubes for features evolving in space and time" submitted to AGILE 2024. 

In this notebook, the expanded code on how to create vector data cubes (VDC) for shape-shifting features as described in section 3.2 (Vector data cube implementation) is included.

Note that the stand-alone code to recreate the figures of the manuscript can be browsed here ([manuscript-figures.qmd](code/manuscript-figures.qmd)).

These experiments are performed in R v. 4.3.2 and further details on library versions are included at the end of the notebook.

# Libraries

The following chunk installs the needed libraries. Run only if overwriting current installations is not an issue. Note that `cubble`, `ggplot` and `ggnewscale` come from the GitHub repository.

```{r}
#| eval: false
#| message: false
#| warning: false
pkgs = c(
  "dplyr","here","patchwork","purrr",
  "readr","stars","stringr",
  "tidyr","tsibble","units","zen4R"
)
install.packages(pkgs)
remotes::install_github("huizezhang-sherry/cubble")
remotes::install_github("tidyverse/ggplot2")
remotes::install_github("eliocamp/ggnewscale")
```

The libraries needed to reproduce this notebook are listed below.

```{r}
#| message: false
#| warning: false
library(cubble) # tabular VDCs
library(dplyr) # data wrangling
library(ggplot2) # visualisation
library(ggnewscale) # add second color/fill scale in ggplot
library(here) # manage current directory
library(patchwork) # plot composer
library(purrr) # functional programming 
library(readr) # read CSV files
library(stars) # array VDCs
library(stringr) # handle strings
library(tidyr) # create tidy data
library(tsibble) # handle time series data
library(units) # set units
library(zen4R) # download data from zenodo
```

# Data and pre-processing

Both data sets are shared through Zenodo, therefore we will directly fetch the necessary data from this repository using `zen4R`.

## Lava flows in Fagradalsfjall, Iceland

The lava flow outlines for the Fagradalsfjall eruption can be obtained from @pedersen_2023_7866738. 

### Repository description

This is the description attached to the repository.

```{r}
#| results = "asis"
zenodo = get_zenodo(
  doi = "10.5281/zenodo.7866738"
)
zenodo$metadata$description
```

### Files

As we see, the vector data format is GeoPackage.
These are the files contained in the repository:

```{r}
zenodo$files
```

From an inspection on the Zenodo listing we could see that the outline for each date is saved as a different file.

### Download and read

Hence, we will download only the outlines zipped file, unzip and create a list of the GeoPackage files to read into memory.

```{r}
#| label: downloadlf
#| eval: false
dir = tempdir()
download_zenodo(
  doi = "10.5281/zenodo.7866738",
  path = dir,
  files = list(
    "outlines_pedersen_etal2022_v12.zip"
  ),
  overwrite = FALSE,
  timeout = 600
)

# Unzip
files = list.files(here(dir), full.names = TRUE)
lapply(files, unzip, exdir = here(dir, "unzipped"))

# Find geopackage files
fn_gpkg = list.files(
  here(dir, "unzipped"),
  pattern = "Outline.*gpkg$",
  full.names = TRUE,
  recursive = TRUE
)
```

```{r}
#| label: temporarychunklfdata
data_dir = here("data", "raw", "lava-flows",
                "fagradalsfjall")
fn_gpkg = list.files(
  here(data_dir, "unzipped"),
  pattern = "Outline.*gpkg$",
  full.names = TRUE,
  recursive = TRUE
)
```

With this we can read in the files into R as an `sf` object, where we combine all the files into one. 
The filename is kept to extract the date information from it.

```{r}
#| label: readlf
# Create function to read in each file and to extract 
# the date from the filename
read_fun = function(x){
  read_sf(x) |> 
    mutate(
      fn_gpkg = tail(str_split(x, '/')[[1]], n=1),
      datetime = as.POSIXct(
        paste(str_split(fn_gpkg, "_")[[1]][2:3], collapse = ""),
        format = "%Y%m%d%H%M"
      )
    ) |> 
    # One file does not have a crs set
    st_set_crs(3057)
}

# Call map2 to read in the files
# and bind them into one single sf object
outlines_lf = map(fn_gpkg, read_fun) |> bind_rows()
```

### Explore

We can look at the final object and have an initial idea of the contents. 

```{r}
outlines_lf |> glimpse()
```

As seen, the columns accompanying the data are not complete and also do not provide extra information. 
We will mainly focus on the geometry and the datetime registered.
We can take a short look at the polygons included in the data:

```{r}
ggplot(outlines_lf) +
  geom_sf(aes(color = datetime), fill = NA) 
```

### Prepare for VDC

The final step is to make sure we have a single geometry per timestamp.
For this, we group by datetime and summarise the geometries for each data with a union.
We add a step to make the geometry valid in case the union operation caused any topological issues.

```{r}
outlines_lf = outlines_lf |> 
  # Combine polygons from single date into multipolygons
  group_by(datetime) |> 
  summarise(geom = st_combine(geom)) |> 
  ungroup() |> 
  # Make geometry valid
  st_make_valid()
```

Now our data is ready to be coerced to a VDC.

## Landslide in Butangbunasi, Taiwan

The Butangbunasi landslide outlines can be obtained from @Hoelbling_2024_Butangbunasidata.

### Repository description

This is the description attached to the repository.

```{r}
#| results = "asis"
zenodo = get_zenodo(
  doi = "10.5281/zenodo.10635102"
)
zenodo$metadata$description
```

### Files

Again, the vector data format is GeoPackage.
These are the files contained in the repository:

```{r}
zenodo$files
```

### Download and read

From exploring the repository and checking the description, we concluded the "Butangbunasi_OBIA_statistics.csv" also contains valuable information that can be join into the outline data frames.

```{r}
#| label: downloadldsl
#| eval: false
# Fetch also the CSV file with addiontional info
dir = tempdir()
download_zenodo(
  doi = "10.5281/zenodo.10635102",
  path = dir,
  files = list(
    "outlines.zip",
    "Butangbunasi_OBIA_statistics.csv"
  ),
  overwrite = FALSE,
  timeout = 100
)

# Unzip
files = list.files(here(dir), full.names = TRUE)
lapply(files, unzip, exdir = here(dir, "unzipped"))

# Find geopackage files
mapping_ls = list.files(
  here(dir, "unzipped", "outlines"), 
  pattern = ".gpkg",
  full.names = TRUE
)
```

```{r}
#| label: temporarychunkldsldata
dir = here("data", "raw", "landslides",
                "butangbunasi")
mapping_ls = list.files(
  here(dir, "unzipped", "outlines"), 
  pattern = ".gpkg",
  full.names = TRUE
)
```

We can then read in the CSV file and the outline files.
With a left join, we can obtain the date and other columns from the CSV file. 

```{r}
#| label: readldsl
#| warning: false
#| message: false
# Read in CSV file
stats = read_csv(
  here(dir, "Butangbunasi_OBIA_statistics.csv")
)

# Set-up a read function that fetches filename
read_fun = function(x){
  read_sf(x) |> 
    mutate(
      fn_gpkg = tail(str_split(x, '/')[[1]], n=1),
    )
}

# Read files and combine into single sf object
# Join with CSV file
outlines_ldsl = lapply(mapping_ls, read_fun) |> 
  bind_rows() |> 
  left_join(stats, by = c("fn_gpkg" = "file"))
```

### Explore

We can look at the final object and have an initial idea of the contents. 

```{r}
outlines_ldsl |> glimpse()
```

For this case, the CSV file added some extra information to the data, such as the satellite sensor and the landslide area.
We see also the column class and lake area which suggests there is more than one class for this dataset. 
Let's look at the polygons included in the data:

```{r}
ggplot(arrange(outlines_ldsl, desc(date))) +
  geom_sf(aes(color = date, fill = Class), alpha = 0.2) +
  scale_color_viridis_c(trans = "date") +
  scale_fill_manual(values = c("deepskyblue3", "peru"))
```

We see here that the data does not only contain the landslide outlines but also the delineation of a dammed lake. 

### Prepare for VDC

```{r}
outlines_ldsl = outlines_ldsl |> 
  # Coerce date column to Date class
  mutate(date = as.Date(date)) |> 
  # Remove outline for 2018
  # this is a reference outline and does not follow a
  # Typhoon event according to Hoelbling et al., 2020
  filter(date != as.Date("2018-11-08")) |>
  # Group by date which in combination with summarise
  # will union all single polygons into a multipolygon
  group_by(date, Class) |> 
  # Summarise sensor and area information for landslide
  summarise(
    sensor = first(satellite_sensor),
    area_ldsl = set_units(first(landslide_area_ha), 'ha'),
    area_lake = set_units(first(lake_area_ha), 'ha')
  ) |> 
  ungroup() |> 
  # collapse the area column into a single one depending on Class
  mutate(
    area = case_when(
      Class == "landslide" ~ area_ldsl,
      Class == "lake" ~ area_lake
    )
  ) |> 
  select(-starts_with("area_")) |> 
  # Complete data for missing cases of date-Class combination
  complete(date, Class) |> 
  # rename the class column (lowercase)
  rename(class = Class) |> 
  # convert back to sf
  st_as_sf()
```

# VDC creation

## Array format

We will start creating an array VDC for the shape-evolving features.
For this, we create an array object containing the data, i.e., the measure, that in this case are the changing geometries, and the dimensions of the array that correspond to the length of unique summary geometries (in this case 1), and of unique datetime strings.

Finally, we create a dimensions object that includes the *summary geometry* for our shape-evolving features.
This can be the union of all the changing geometries or the centroid of those or the point from which the lava erupts or the landslide scar, or any other point the analyst sees adequate.

### Lava flow VDC

For the lava flow, we do not use a unique identifier (`id`) because this is the only feature of this class under analysis.
That means we are not including a second lava flow, e.g. the one in Grindavík, in the same cube, although we could when data is available.

```{r}
# Create array
a = array(
  data = outlines_lf$geom, 
  dim = c(
    1,
    length(unique(outlines_lf$datetime))
  ),
  dimnames = list(
    geom_sum = 1,
    datetime = unique(outlines_lf$datetime)
  )
)

# Create dimensions object
# Summary geometry is the centroid of the union of all geometries
# The point parameter indicates if the value refers to a point (location)
# or to a pixel (area) value
dim_cent = st_dimensions(
  geom_sum = st_centroid(st_make_valid(st_union(outlines_lf$geom))), 
  datetime = unique(outlines_lf$datetime),
  point = c(TRUE, FALSE)
)

# Coerce to cube
(cube_arr_lf = st_as_stars(
  list(geometry = a), 
  dimensions = dim_cent)
)
```

If we would use the union we will see under the values column of the `geom_sum` dimension not a `POINT` geometry as above but a `POLYGON` geometry.
We illustrate this with an unsaved object, so we will keep working with the centroid as the `geom_sum`.

```{r}
dim_union = st_dimensions(
  geom_sum = st_make_valid(st_union(outlines_lf$geom)), 
  datetime = unique(outlines_lf$datetime),
  point = c(TRUE, FALSE)
)

# Coerce to cube
st_as_stars(
  list(geometry = a), 
  dimensions = dim_union)
```

### Landslide VDC

For the landslide example we have added also the landslide-dammed lake outlines. 
The lake has been present in seven of the Landsat scenes mapped and therefore can serve as an example on how to handle absence in the data, as well as a second feature set in a VDC.

In this example, we add `class` as an extra dimension, which will mark whether the shape-evolving geometry is a landslide or a lake.
For this particular case this dimension becomes redundant since there are two classes and two summary geometries, however, when we deal with more landslides and associated lakes, this could become useful.
We will notice data redundancy by checking the amount of geometries in the summary of the attributes, we had initially 40 geometries and now we have 80, with 53 empty geometries.

We will perform some extra data wrangling to create this cube. 
Namely, we compute the *summary geometry* on the original `sf` object and perform again a complete case check to fill values with `NA`s for every combination of `date`, `class` and `geom_sum`.

Further, this dataset contains other information that can be mapped to the attributes such as the sensor and area.
We will construct separate arrays for these and add them all to the cube.

```{r}
# Add geom_sum columns to original sf data
# will be used also to create tabular VDC
outlines_ldsl_m = outlines_ldsl |> 
  # Summary geometry is the centroid of the union 
  # of all geometries per type
  group_by(class) |> 
  mutate(
    geom_sum = st_centroid(st_make_valid(st_union(geom)))
  ) |> 
  relocate(geom_sum, .after = everything()) |> 
  ungroup() |> 
  st_as_sf(sf_column_name = 'geom_sum') 

# Complete cases, saved as separate object, see tabular format
outlines_ldsl_c = outlines_ldsl_m |> 
  complete(date, class, geom_sum) |> 
  st_as_sf(sf_column_name = 'geom_sum')

# Create arrays
dims = c(
    length(unique(outlines_ldsl_c$geom_sum)),
    length(unique(outlines_ldsl_c$class)),
    length(unique(outlines_ldsl_c$date))
  )
dnms = list(
    geom_sum = unique(outlines_ldsl_c$geom_sum),
    class = unique(outlines_ldsl_c$class),
    datetime = unique(outlines_ldsl_c$date)
  )
geom = array(
  data = outlines_ldsl_c$geom, 
  dim = dims,
  dimnames = dnms
)
area = array(
  data = outlines_ldsl_c$area, 
  dim = dims,
  dimnames = dnms
)
sensor = array(
  data = outlines_ldsl_c$sensor, 
  dim = dims,
  dimnames = dnms
)

# Summarise geometries to add in dimensions object
sumgeom = outlines_ldsl_c |> 
  group_by(class) |> 
  summarise(geom_sum = first(geom_sum))

# Create dimensions object
# The point parameter indicates if the value refers to a point (location)
# or to a pixel (area) value
dim_cent = st_dimensions(
  geom_sum = sumgeom$geom_sum, 
  class = unique(outlines_ldsl_c$class),
  date = unique(outlines_ldsl_c$date)
  # point = c(TRUE, TRUE, FALSE)
)

# Coerce to cube
(cube_arr_ldsl = st_as_stars(
  list(geometry = geom, area = area, sensor = sensor), 
  dimensions = dim_cent)
)
```

## Tabular format

For the tabular format we use `cubble`. 
We can either coerce the `stars` VDC into a `cubble` (as shown for the lava flow example), or we can create a `cubble` from the original `sf` object (as shown for the landslide example).

For this format, we need to define a `key` and `index.` The key is the identifier of the spatial face of the cube while the index is the identifier of the temporal face.
We then use `key = gid` and `index = time`.

### Lava flow VDC

As mentioned above, this VDC is created from the `stars` VDC. 

```{r}
cube_tab_lf = as_cubble(
  cube_arr_lf, key = id, index = datetime
)
```

We can see the temporal and spatial faces of the cube.
As we will see `ts` in the spatial table is a list column where the time series is stored as displayed in the temporal table.

```{r}
cube_tab_lf |> 
  face_spatial()
cube_tab_lf |> 
  face_temporal()
```

What is interesting from this tabular format is that the `tsibble` package is used under the hood to handle the temporal aspect.
Therefore, information on time intervals is inferred from the given timestamps and it is therefore determined if the time series has any gaps.

### Landslide VDC

For this VDC we will use the modified `sf` object for the landslide dataset.
We have included here the version without the complete cases for the three dimensions because `cubble` throws an error for this.
Further investigation into why this is the case will follow for future work.

```{r}
## Create cubble
cube_tab_ldsl = as_cubble(
  outlines_ldsl_m, key = class, index = date
)
```

We can see the temporal and spatial faces of the cube.
Here we note how the "lake" and "landslide" become the identifiers for the feature sets.

```{r}
cube_tab_ldsl |> 
  face_spatial()
cube_tab_ldsl |> 
  face_temporal()
```

# Showcase

In this section, we will demonstrate some of the operations that are supported now for VDCs, and some of the operations that we would like to implement in future work.

We will use the created cubes (lava flow, landslide) interchangeably, considering that most of the operations (given the data structure, e.g., extra dimensions, extra attributes) can be applied to both examples.

## Cube operations

Most of `dplyr` verbs and `sf` functions work for the array and tabular cubes.
For the tabular cubes, it is important to remember which face we want to apply the operation to.

### Geometric measurements

```{r}
cube_arr_lf |> 
  mutate(area = st_area(geometry))

cube_tab_lf |> 
  face_temporal() |> 
  mutate(area = st_area(geometry))
```

### Subsetting dimensions

Subsetting refers to lookup operations via an index.
A way to subset a cube is to use the slice verb. 
Similar results can be achieved with `[`, but the syntax is not so intuitive and we need to know the dimension order.
When a dimension after slicing has a single index it is dropped by default.
Note how the number of geometries in the attributes changes.

```{r}
cube_arr_lf |> 
  slice(index = 3:12, along = "datetime")

cube_arr_lf[,,3:12]

cube_arr_ldsl |> 
  slice(index = 1, along = "class")
```

### Selecting attributes

We can select single attributes or columns. 
Note that for the tabular format the `key` and `index` behave as sticky columns and always stay.

```{r}
cube_arr_ldsl |> 
  select(sensor)

cube_tab_ldsl |> 
  face_temporal() |> 
  select(sensor)
```

### Filtering time

```{r}
cube_arr_lf |> 
  filter(datetime > "2021-03-18", datetime < "2021-03-25")

cube_tab_lf |> 
  face_temporal() |> 
  filter(datetime > "2021-03-18", datetime < "2021-03-25")
```

### CRS transformation

Transforming the CRS of the VDC works for both the tabular and array formats.
However, the changing geometries preserve their original CRS, even though the *summary_geometry* is modified for both formats.

In future work, we aim for a better integration of the *summary geometry* and *shape-evolving geometries*, where both geometry-columns get updated with such operations.

```{r}
test_arr = cube_arr_lf |> 
  st_transform(4326)
test_arr
test_arr$geometry

test_tab = cube_tab_lf |>  
  st_transform(4326)
test_tab
test_tab |> face_temporal()
```

### Differences in time series

For the tabular format, we can use `tsibble` functions when coercing our cube into a temporal tsibble.
One useful function is to calculate differences between timestamps.
We use this for computing the difference in area (per feature class for the landslide example) below.

```{r}
cube_tab_lf |> 
  face_temporal() |> 
  mutate(area = set_units(st_area(geometry), "ha")) |> 
  make_temporal_tsibble() |> 
  mutate(diff = difference(area, order_by = datetime))

cube_tab_ldsl |> 
  face_temporal() |> 
  make_temporal_tsibble() |> 
  group_by(class) |> 
  mutate(diff = difference(area, order_by = date)) |> 
  ungroup() |> 
  arrange(rev(class))
```

Functions like spatial filtering and data aggregations would become more relevant when we deal with a larger number of feature sets, and will be explored for future implementations of the VDC concepts.

## Visualisation

# References
::: {#refs}
:::

# R Session Info {#sec-session}

```{r}
sessionInfo()
```
